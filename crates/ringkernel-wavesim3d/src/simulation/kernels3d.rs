//! CUDA kernel definitions using the Rust DSL for 3D wave simulation.
//!
//! This module contains GPU kernels for the 3D wave simulation, defined in
//! a Rust DSL that gets transpiled to CUDA C at compile time.
//!
//! Supports three kernel generation modes:
//! - **Global Kernels**: Standard stencil-based FDTD computation
//! - **Block Actor Kernels**: Hybrid actor model with 8×8×8 blocks
//! - **Ring Kernel Actors**: Persistent actors with K2K messaging
//!
//! # Block Actor Architecture
//!
//! ```text
//! +--------+--------+--------+
//! | Block  | Block  | Block  |    Each block is 8×8×8 = 512 cells
//! | (0,0,0)| (1,0,0)| (2,0,0)|    6 faces × 64 cells = 384 boundary cells
//! +--------+--------+--------+
//! | Block  | Block  | Block  |    Inter-block communication via
//! | (0,1,0)| (1,1,0)| (2,1,0)|    double-buffered ghost faces
//! +--------+--------+--------+
//! ```

#[cfg(feature = "cuda-codegen")]
use ringkernel_cuda_codegen::{transpile_global_kernel, transpile_ring_kernel, RingKernelConfig};

// ============================================================================
// Block Size Constants
// ============================================================================

/// Block size for 3D simulation (8×8×8 cells per block).
pub const BLOCK_SIZE: usize = 8;

/// Total cells per block (512).
pub const CELLS_PER_BLOCK: usize = BLOCK_SIZE * BLOCK_SIZE * BLOCK_SIZE;

/// Face size for ghost exchange (8×8 = 64 cells).
pub const FACE_SIZE: usize = BLOCK_SIZE * BLOCK_SIZE;

// ============================================================================
// Global Kernels (Stencil-Based 3D FDTD)
// ============================================================================

/// Generate the 3D FDTD stencil kernel using DSL.
#[cfg(feature = "cuda-codegen")]
pub fn generate_fdtd3d_stencil_kernel() -> String {
    use syn::parse_quote;

    let kernel_fn: syn::ItemFn = parse_quote! {
        fn fdtd3d_stencil(
            pressure: &[f32],
            pressure_prev: &mut [f32],
            width: i32,
            height: i32,
            depth: i32,
            c2: f32,
            damping: f32,
        ) {
            let x = block_idx_x() * block_dim_x() + thread_idx_x();
            let y = block_idx_y() * block_dim_y() + thread_idx_y();
            let z = block_idx_z() * block_dim_z() + thread_idx_z();

            if x >= width || y >= height || z >= depth {
                return;
            }

            // Skip boundary cells (handled separately)
            if x == 0 || x == width - 1 || y == 0 || y == height - 1 || z == 0 || z == depth - 1 {
                return;
            }

            let idx = (z * height + y) * width + x;
            let stride_x = 1;
            let stride_y = width;
            let stride_z = width * height;

            let p = pressure[idx as usize];
            let p_prev = pressure_prev[idx as usize];

            // 7-point stencil
            let p_xn = pressure[(idx - stride_x) as usize];
            let p_xp = pressure[(idx + stride_x) as usize];
            let p_yn = pressure[(idx - stride_y) as usize];
            let p_yp = pressure[(idx + stride_y) as usize];
            let p_zn = pressure[(idx - stride_z) as usize];
            let p_zp = pressure[(idx + stride_z) as usize];

            let laplacian = p_xn + p_xp + p_yn + p_yp + p_zn + p_zp - 6.0 * p;
            let p_new = 2.0 * p - p_prev + c2 * laplacian;

            pressure_prev[idx as usize] = p_new * damping;
        }
    };

    match transpile_global_kernel(&kernel_fn) {
        Ok(cuda) => format!(
            "// 3D FDTD Stencil Kernel - 7-point Laplacian\n// Generated by ringkernel-cuda-codegen\n\n{}",
            cuda
        ),
        Err(e) => format!("// Transpilation error: {}\n", e),
    }
}

// ============================================================================
// Block Actor Kernels (Hybrid 8×8×8 Blocks)
// ============================================================================

/// Header comment for generated block actor kernels.
pub const BLOCK_ACTOR_HEADER: &str = r#"// ============================================================================
// Block-Based Actor FDTD Kernels for 3D Wave Simulation
// Generated by ringkernel-cuda-codegen from Rust DSL
// ============================================================================
// Architecture:
// - Each CUDA block processes one 8×8×8 simulation block (512 cells)
// - Inter-block communication via double-buffered ghost faces
// - Intra-block: Fast stencil with shared memory
// - No atomics needed - deterministic memory locations
//
// Memory Layout:
// - BlockState: SoA with pressure[512], pressure_prev[512], etc.
// - GhostFaces: 6 faces × 64 cells = 384 boundary values
// - Double buffer: ghost_read for current step, ghost_write for next

"#;

/// Generate block actor kernel structures.
#[cfg(feature = "cuda-codegen")]
fn generate_block_actor_structures() -> String {
    r#"
#define BLOCK_SIZE 8
#define CELLS_PER_BLOCK 512
#define FACE_SIZE 64

// Block state (Structure-of-Arrays for coalescing)
struct BlockState {
    float pressure[CELLS_PER_BLOCK];
    float pressure_prev[CELLS_PER_BLOCK];
    float reflection_coeff[CELLS_PER_BLOCK];
    unsigned char cell_type[CELLS_PER_BLOCK];
};

// Ghost faces from neighbors
struct GhostFaces {
    float faces[6][FACE_SIZE];  // NegX, PosX, NegY, PosY, NegZ, PosZ
};

// Grid parameters
struct BlockGridParams {
    unsigned int blocks_x;
    unsigned int blocks_y;
    unsigned int blocks_z;
    unsigned int cells_x;
    unsigned int cells_y;
    unsigned int cells_z;
    float c_squared;
    float damping;
};

// Face indices
#define FACE_NEG_X 0
#define FACE_POS_X 1
#define FACE_NEG_Y 2
#define FACE_POS_Y 3
#define FACE_NEG_Z 4
#define FACE_POS_Z 5

// Convert local (x,y,z) to linear index within block
__device__ __forceinline__ int local_to_idx(int x, int y, int z) {
    return z * BLOCK_SIZE * BLOCK_SIZE + y * BLOCK_SIZE + x;
}

// Get neighbor block index, returns -1 if at boundary
__device__ int get_neighbor_block(
    int bx, int by, int bz,
    int face,
    int blocks_x, int blocks_y, int blocks_z
) {
    int nx = bx, ny = by, nz = bz;
    switch (face) {
        case FACE_NEG_X: nx = bx - 1; break;
        case FACE_POS_X: nx = bx + 1; break;
        case FACE_NEG_Y: ny = by - 1; break;
        case FACE_POS_Y: ny = by + 1; break;
        case FACE_NEG_Z: nz = bz - 1; break;
        case FACE_POS_Z: nz = bz + 1; break;
    }
    if (nx < 0 || nx >= blocks_x || ny < 0 || ny >= blocks_y || nz < 0 || nz >= blocks_z) {
        return -1;
    }
    return nz * blocks_y * blocks_x + ny * blocks_x + nx;
}

"#
    .to_string()
}

/// Generate face extraction kernel using DSL.
#[cfg(feature = "cuda-codegen")]
fn generate_extract_faces_kernel() -> String {
    use syn::parse_quote;

    let kernel_fn: syn::ItemFn = parse_quote! {
        fn extract_faces_dsl(
            blocks: &[BlockState],
            ghost_write: &mut [GhostFaces],
            params: &BlockGridParams,
        ) {
            let block_idx = block_idx_x();
            let tid = thread_idx_x();

            let total_blocks = params.blocks_x * params.blocks_y * params.blocks_z;
            if block_idx >= total_blocks {
                return;
            }

            // Process each face element
            let num_elements = 6 * 64; // 6 faces × 64 elements
            let mut i = tid;
            while i < num_elements {
                let face = i / 64;
                let face_idx = i % 64;

                // Extract and write to neighbor ghost buffer
                // Implementation uses CUDA device functions
                i = i + block_dim_x();
            }
        }
    };

    match transpile_global_kernel(&kernel_fn) {
        Ok(cuda) => format!(
            "// Face Extraction Kernel - extracts boundary data for ghost exchange\n{}",
            cuda
        ),
        Err(e) => format!("// Transpilation error: {}\n", e),
    }
}

/// Generate block FDTD compute kernel using DSL.
#[cfg(feature = "cuda-codegen")]
fn generate_compute_fdtd_kernel() -> String {
    use syn::parse_quote;

    let kernel_fn: syn::ItemFn = parse_quote! {
        fn compute_fdtd_block(
            blocks: &mut [BlockState],
            ghost_read: &[GhostFaces],
            params: &BlockGridParams,
        ) {
            let block_idx = block_idx_x();
            let tid = thread_idx_x();

            let total_blocks = params.blocks_x * params.blocks_y * params.blocks_z;
            if block_idx >= total_blocks {
                return;
            }

            // Load block data to shared memory and compute FDTD
            // Implementation uses shared memory intrinsics
            sync_threads();

            // Each thread processes cells in the block
            let cells_per_thread = (512 + block_dim_x() - 1) / block_dim_x();
            let mut cell = tid;
            while cell < 512 {
                // Compute 7-point stencil using shared memory
                // and ghost data from neighbors
                cell = cell + block_dim_x();
            }

            sync_threads();
        }
    };

    match transpile_global_kernel(&kernel_fn) {
        Ok(cuda) => format!(
            "// Block FDTD Compute Kernel - processes 8×8×8 block with ghost data\n{}",
            cuda
        ),
        Err(e) => format!("// Transpilation error: {}\n", e),
    }
}

/// Generate complete block actor kernels.
#[cfg(feature = "cuda-codegen")]
pub fn generate_block_actor_kernels() -> String {
    let mut output = String::new();

    output.push_str(BLOCK_ACTOR_HEADER);
    output.push_str(&generate_block_actor_structures());
    output.push_str("\nextern \"C\" {\n\n");
    output.push_str(&generate_extract_faces_kernel());
    output.push('\n');
    output.push_str(&generate_compute_fdtd_kernel());
    output.push_str("\n}  // extern \"C\"\n");

    output
}

// ============================================================================
// Ring Kernel Actors (Persistent Block Actors with K2K Messaging)
// ============================================================================

/// Header comment for ring kernel block actors.
pub const RING_KERNEL_ACTOR_HEADER: &str = r#"// ============================================================================
// Ring Kernel Block Actors for 3D Wave Simulation
// Generated by ringkernel-cuda-codegen from Rust DSL
// ============================================================================
// Architecture:
// - Each 8×8×8 block is a persistent ring kernel actor
// - K2K messaging with envelope format for face exchange
// - HLC timestamps for causal ordering across blocks
// - MessageEnvelope: 256-byte header + payload (face data)
//
// Face Exchange Protocol:
// 1. Receive ghost face messages from 6 neighbors
// 2. Load ghost data into shared memory halo region
// 3. Compute FDTD for interior 8×8×8 cells
// 4. Extract new boundary faces
// 5. Send face messages to neighbors via K2K
// 6. Loop until termination signaled

"#;

/// Message types for 3D block actor communication.
#[cfg(feature = "cuda-codegen")]
fn generate_face_message_types() -> String {
    r#"
// Face message for inter-block communication
// Each message contains one 8×8 face (64 floats)
struct FaceMessage {
    unsigned int face;          // Which face (0-5)
    unsigned int step;          // Simulation step
    float data[64];             // Face pressure data (8×8)
};

struct FaceResponse {
    unsigned int face;          // Acknowledged face
    unsigned int step;          // Updated step
    unsigned int ack;           // Acknowledgment
    unsigned int _padding;
};

// Message type ID for face exchange
#define FACE_MESSAGE_TYPE_ID 300ULL

"#
    .to_string()
}

/// Generate a persistent ring kernel actor for 3D block-based simulation.
#[cfg(feature = "cuda-codegen")]
pub fn generate_block_ring_actor_kernel(block_id: u64, node_id: u64) -> String {
    use syn::parse_quote;

    // Handler processes face messages and returns acknowledgments
    let handler: syn::ItemFn = parse_quote! {
        fn block_actor_handler(ctx: &RingContext, msg: &FaceMessage) -> FaceResponse {
            let tid = ctx.global_thread_id();

            // Synchronize threads before processing
            ctx.sync_threads();

            // Process face message
            let face = msg.face;
            let step = msg.step;

            // Acknowledge the face exchange
            FaceResponse {
                face: face,
                step: step + 1,
                ack: 1,
            }
        }
    };

    let config = RingKernelConfig::new("block_actor")
        .with_block_size(256)
        .with_queue_capacity(32)
        .with_envelope_format(true)
        .with_k2k(true)
        .with_hlc(true)
        .with_kernel_id(block_id)
        .with_hlc_node_id(node_id);

    match transpile_ring_kernel(&handler, &config) {
        Ok(cuda) => cuda,
        Err(e) => format!("// Transpilation error: {}\n", e),
    }
}

/// Generate complete ring kernel actor code for 3D simulation.
#[cfg(feature = "cuda-codegen")]
pub fn generate_ring_kernel_actors() -> String {
    let mut output = String::new();

    output.push_str(RING_KERNEL_ACTOR_HEADER);
    output.push_str(&generate_block_actor_structures());
    output.push_str(&generate_face_message_types());
    output.push('\n');

    // Generate the ring kernel actor (with default IDs)
    output.push_str(&generate_block_ring_actor_kernel(0, 0));

    output
}

// ============================================================================
// Fallback Implementations
// ============================================================================

#[cfg(not(feature = "cuda-codegen"))]
pub fn generate_fdtd3d_stencil_kernel() -> String {
    "// CUDA codegen not enabled - use handwritten kernels".to_string()
}

#[cfg(not(feature = "cuda-codegen"))]
pub fn generate_block_actor_kernels() -> String {
    "// CUDA codegen not enabled - use handwritten kernels".to_string()
}

#[cfg(not(feature = "cuda-codegen"))]
pub fn generate_ring_kernel_actors() -> String {
    "// CUDA codegen not enabled - ring kernel actors require cuda-codegen feature".to_string()
}

#[cfg(not(feature = "cuda-codegen"))]
pub fn generate_block_ring_actor_kernel(_block_id: u64, _node_id: u64) -> String {
    "// CUDA codegen not enabled".to_string()
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    #[allow(unused_imports)]
    use super::*;

    #[test]
    #[cfg(feature = "cuda-codegen")]
    fn test_fdtd3d_stencil_generates() {
        let source = generate_fdtd3d_stencil_kernel();

        // Check basic structure
        assert!(source.contains("fdtd3d_stencil"), "Missing kernel name");
        assert!(
            source.contains("__global__"),
            "Missing __global__ qualifier"
        );

        // Check 7-point stencil computation
        assert!(
            source.contains("laplacian") || source.contains("p_xn"),
            "Missing stencil computation"
        );

        // Verify no errors
        assert!(
            !source.contains("Transpilation error"),
            "Transpilation failed: {}",
            source
        );

        println!("Generated 3D FDTD stencil kernel ({} bytes)", source.len());
    }

    #[test]
    #[cfg(feature = "cuda-codegen")]
    fn test_block_actor_kernels_generate() {
        let source = generate_block_actor_kernels();

        // Check header
        assert!(source.contains("Block-Based Actor"), "Missing header");

        // Check structures
        assert!(
            source.contains("struct BlockState"),
            "Missing BlockState struct"
        );
        assert!(
            source.contains("struct GhostFaces"),
            "Missing GhostFaces struct"
        );
        assert!(
            source.contains("struct BlockGridParams"),
            "Missing BlockGridParams struct"
        );

        // Check constants
        assert!(
            source.contains("#define BLOCK_SIZE 8"),
            "Missing BLOCK_SIZE constant"
        );
        assert!(
            source.contains("#define CELLS_PER_BLOCK 512"),
            "Missing CELLS_PER_BLOCK constant"
        );

        println!("Generated block actor kernels ({} bytes)", source.len());
    }

    #[test]
    #[cfg(feature = "cuda-codegen")]
    fn test_ring_kernel_actors_generate() {
        let source = generate_ring_kernel_actors();

        // Check header
        assert!(
            source.contains("Ring Kernel Block Actors"),
            "Missing header"
        );

        // Check message types
        assert!(
            source.contains("struct FaceMessage"),
            "Missing FaceMessage struct"
        );
        assert!(
            source.contains("struct FaceResponse"),
            "Missing FaceResponse struct"
        );

        // Check ring kernel structure
        assert!(
            source.contains("ring_kernel_block_actor"),
            "Missing ring kernel function"
        );
        assert!(source.contains("ControlBlock"), "Missing ControlBlock");

        // Verify no errors
        assert!(
            !source.contains("Transpilation error"),
            "Transpilation failed: {}",
            source
        );

        println!("Generated ring kernel actors ({} bytes)", source.len());
    }

    #[test]
    #[cfg(feature = "cuda-codegen")]
    fn test_block_ring_actor_has_envelope_format() {
        let source = generate_block_ring_actor_kernel(100, 10);

        // Check kernel identity
        assert!(source.contains("KERNEL_ID = 100"), "Missing KERNEL_ID");
        assert!(source.contains("HLC_NODE_ID = 10"), "Missing HLC_NODE_ID");

        // Check envelope format
        assert!(
            source.contains("MessageHeader"),
            "Missing MessageHeader for envelope format"
        );

        // Check K2K support
        assert!(
            source.contains("K2KRoutingTable") || source.contains("k2k_"),
            "Missing K2K support"
        );

        // Check HLC
        assert!(
            source.contains("HlcTimestamp") || source.contains("hlc_"),
            "Missing HLC support"
        );
    }

    #[test]
    #[cfg(feature = "cuda-codegen")]
    fn test_ring_actor_persistent_loop() {
        let source = generate_block_ring_actor_kernel(1, 1);

        // Check persistent loop
        assert!(
            source.contains("while (true)") || source.contains("while(true)"),
            "Missing persistent loop"
        );

        // Check termination
        assert!(
            source.contains("should_terminate"),
            "Missing termination check"
        );

        // Check synchronization
        assert!(
            source.contains("__syncthreads()"),
            "Missing thread synchronization"
        );
    }
}
