//! IR to MSL (Metal Shading Language) lowering pass.
//!
//! Lowers IR to Metal Shading Language for Apple GPU compute.

use std::collections::HashMap;
use std::fmt::Write;

use crate::{
    nodes::*, BlockId, CapabilityFlag, Dimension, IrModule, IrNode, IrType, ScalarType, Terminator,
    ValueId,
};

/// MSL lowering configuration.
#[derive(Debug, Clone)]
pub struct MslLoweringConfig {
    /// Metal language version (e.g., 2.4, 3.0).
    pub metal_version: (u32, u32),
    /// Enable SIMD group operations.
    pub simd_groups: bool,
    /// Threadgroup size.
    pub threadgroup_size: (u32, u32, u32),
    /// Enable indirect command buffers.
    pub indirect_commands: bool,
    /// Enable HLC (Hybrid Logical Clocks).
    pub enable_hlc: bool,
    /// Enable K2K messaging.
    pub enable_k2k: bool,
    /// Generate debug comments.
    pub debug: bool,
}

impl Default for MslLoweringConfig {
    fn default() -> Self {
        Self {
            metal_version: (2, 4),
            threadgroup_size: (256, 1, 1),
            simd_groups: true,
            indirect_commands: false,
            enable_hlc: false,
            enable_k2k: false,
            debug: false,
        }
    }
}

impl MslLoweringConfig {
    /// Create config for Metal 3.0.
    pub fn metal3() -> Self {
        Self {
            metal_version: (3, 0),
            simd_groups: true,
            indirect_commands: true,
            ..Default::default()
        }
    }

    /// Set threadgroup size.
    pub fn with_threadgroup_size(mut self, x: u32, y: u32, z: u32) -> Self {
        self.threadgroup_size = (x, y, z);
        self
    }

    /// Enable persistent kernel features.
    pub fn with_persistent(mut self) -> Self {
        self.enable_hlc = true;
        self.enable_k2k = true;
        self
    }
}

/// MSL code generator.
pub struct MslLowering {
    config: MslLoweringConfig,
    output: String,
    indent: usize,
    value_names: HashMap<ValueId, String>,
    name_counter: usize,
    block_labels: HashMap<BlockId, String>,
}

impl MslLowering {
    /// Create a new MSL lowering pass.
    pub fn new(config: MslLoweringConfig) -> Self {
        Self {
            config,
            output: String::new(),
            indent: 0,
            value_names: HashMap::new(),
            name_counter: 0,
            block_labels: HashMap::new(),
        }
    }

    /// Lower an IR module to MSL code.
    pub fn lower(mut self, module: &IrModule) -> Result<String, MslLoweringError> {
        // Check capabilities
        self.check_capabilities(module)?;

        // Generate header
        self.emit_header();

        // Generate type definitions
        self.emit_type_definitions(module);

        // Generate kernel
        self.emit_kernel(module)?;

        Ok(self.output)
    }

    fn check_capabilities(&self, module: &IrModule) -> Result<(), MslLoweringError> {
        // Metal doesn't support f64
        if module.required_capabilities.has(CapabilityFlag::Float64) {
            return Err(MslLoweringError::UnsupportedCapability(
                "f64 not supported in Metal (will downcast to f32)".to_string(),
            ));
        }

        // Metal doesn't have true cooperative groups for grid sync
        if module
            .required_capabilities
            .has(CapabilityFlag::CooperativeGroups)
        {
            return Err(MslLoweringError::UnsupportedCapability(
                "Grid-wide sync not supported in Metal".to_string(),
            ));
        }

        Ok(())
    }

    fn emit_header(&mut self) {
        self.emit_line("// Generated by ringkernel-ir MSL lowering");
        self.emit_line("#include <metal_stdlib>");
        self.emit_line("#include <simdgroup_matrix>");
        self.emit_line("using namespace metal;");
        self.emit_line("");
    }

    fn emit_type_definitions(&mut self, _module: &IrModule) {
        // HLC timestamp type
        if self.config.enable_hlc {
            self.emit_line("// HLC Timestamp");
            self.emit_line("struct HlcTimestamp {");
            self.indent += 1;
            self.emit_line("uint64_t physical;");
            self.emit_line("uint64_t logical;");
            self.emit_line("uint64_t node_id;");
            self.indent -= 1;
            self.emit_line("};");
            self.emit_line("");

            // HLC intrinsic declarations
            self.emit_line("// HLC Intrinsics (provided by runtime)");
            self.emit_line("uint64_t ringkernel_hlc_now();");
            self.emit_line("uint64_t ringkernel_hlc_tick();");
            self.emit_line("uint64_t ringkernel_hlc_update(uint64_t incoming);");
            self.emit_line("");
        }

        // K2K messaging types and intrinsics
        if self.config.enable_k2k {
            // Control block
            self.emit_line("// Control Block");
            self.emit_line("struct ControlBlock {");
            self.indent += 1;
            self.emit_line("uint32_t is_active;");
            self.emit_line("uint32_t should_terminate;");
            self.emit_line("uint32_t has_terminated;");
            self.emit_line("uint32_t _pad1;");
            self.emit_line("uint64_t messages_processed;");
            self.emit_line("uint64_t messages_in_flight;");
            self.emit_line("uint64_t input_head;");
            self.emit_line("uint64_t input_tail;");
            self.emit_line("uint64_t output_head;");
            self.emit_line("uint64_t output_tail;");
            self.emit_line("uint32_t input_capacity;");
            self.emit_line("uint32_t output_capacity;");
            self.emit_line("uint32_t input_mask;");
            self.emit_line("uint32_t output_mask;");
            self.indent -= 1;
            self.emit_line("};");
            self.emit_line("");

            // K2H/H2K queue intrinsic declarations
            self.emit_line("// Queue Intrinsics (provided by runtime)");
            self.emit_line("bool ringkernel_k2h_enqueue(const device void* msg);");
            self.emit_line("device void* ringkernel_h2k_dequeue();");
            self.emit_line("bool ringkernel_h2k_is_empty();");
            self.emit_line("");

            // K2K messaging intrinsic declarations
            self.emit_line("// K2K Messaging Intrinsics (provided by runtime)");
            self.emit_line("bool ringkernel_k2k_send(uint64_t target_id, const device void* msg);");
            self.emit_line("device void* ringkernel_k2k_recv();");
            self.emit_line("struct K2KOptionalMsg { bool valid; device void* data; };");
            self.emit_line("K2KOptionalMsg ringkernel_k2k_try_recv();");
            self.emit_line("");
        }
    }

    fn emit_kernel(&mut self, module: &IrModule) -> Result<(), MslLoweringError> {
        // Assign names
        self.assign_names(module);

        // Kernel signature (threadgroup size set at dispatch time)
        self.emit_line("kernel void");
        writeln!(self.output, "{}(", module.name).unwrap();
        self.indent += 1;

        // Parameters
        for (buffer_idx, param) in module.parameters.iter().enumerate() {
            let ty = self.lower_type(&param.ty);
            let qualifier = if param.ty.is_ptr() {
                "device"
            } else {
                "constant"
            };
            self.emit_line(&format!(
                "{} {}& {} [[buffer({})]],",
                qualifier, ty, param.name, buffer_idx
            ));
        }

        // Built-in arguments
        self.emit_line("uint3 thread_position_in_grid [[thread_position_in_grid]],");
        self.emit_line("uint3 thread_position_in_threadgroup [[thread_position_in_threadgroup]],");
        self.emit_line("uint3 threadgroup_position_in_grid [[threadgroup_position_in_grid]],");
        self.emit_line("uint3 threads_per_threadgroup [[threads_per_threadgroup]],");
        self.emit_line("uint3 threadgroups_per_grid [[threadgroups_per_grid]],");
        self.emit_line("uint thread_index_in_simdgroup [[thread_index_in_simdgroup]],");
        self.emit_line("uint simdgroup_index_in_threadgroup [[simdgroup_index_in_threadgroup]]");

        self.indent -= 1;
        self.emit_line(") {");
        self.indent += 1;

        // Emit blocks
        self.emit_block(module, module.entry_block)?;

        self.indent -= 1;
        self.emit_line("}");

        Ok(())
    }

    fn assign_names(&mut self, module: &IrModule) {
        for param in &module.parameters {
            self.value_names.insert(param.value_id, param.name.clone());
        }

        for (block_id, block) in &module.blocks {
            self.block_labels.insert(*block_id, block.label.clone());
        }
    }

    fn emit_block(&mut self, module: &IrModule, block_id: BlockId) -> Result<(), MslLoweringError> {
        let block = module
            .blocks
            .get(&block_id)
            .ok_or(MslLoweringError::UndefinedBlock(block_id))?;

        // Block label (skip for entry)
        if block_id != module.entry_block {
            self.emit_line(&format!("{}: {{", block.label));
            self.indent += 1;
        }

        // Instructions
        for inst in &block.instructions {
            self.emit_instruction(module, &inst.result, &inst.result_type, &inst.node)?;
        }

        // Terminator
        if let Some(term) = &block.terminator {
            self.emit_terminator(module, term)?;
        }

        if block_id != module.entry_block {
            self.indent -= 1;
            self.emit_line("}");
        }

        Ok(())
    }

    fn emit_instruction(
        &mut self,
        _module: &IrModule,
        result: &ValueId,
        result_type: &IrType,
        node: &IrNode,
    ) -> Result<(), MslLoweringError> {
        let result_name = self.get_or_create_name(*result);
        let ty = self.lower_type(result_type);

        match node {
            // Constants
            IrNode::Constant(c) => {
                let val = self.lower_constant(c);
                self.emit_line(&format!("{} {} = {};", ty, result_name, val));
            }

            // Binary operations
            IrNode::BinaryOp(op, lhs, rhs) => {
                let lhs_name = self.get_value_name(*lhs);
                let rhs_name = self.get_value_name(*rhs);
                let expr = self.lower_binary_op(op, &lhs_name, &rhs_name);
                self.emit_line(&format!("{} {} = {};", ty, result_name, expr));
            }

            // Unary operations
            IrNode::UnaryOp(op, val) => {
                let val_name = self.get_value_name(*val);
                let expr = self.lower_unary_op(op, &val_name);
                self.emit_line(&format!("{} {} = {};", ty, result_name, expr));
            }

            // Comparisons
            IrNode::Compare(op, lhs, rhs) => {
                let lhs_name = self.get_value_name(*lhs);
                let rhs_name = self.get_value_name(*rhs);
                let cmp_op = self.lower_compare_op(op);
                self.emit_line(&format!(
                    "bool {} = {} {} {};",
                    result_name, lhs_name, cmp_op, rhs_name
                ));
            }

            // Memory operations
            IrNode::Load(ptr) => {
                let ptr_name = self.get_value_name(*ptr);
                self.emit_line(&format!("{} {} = {};", ty, result_name, ptr_name));
            }

            IrNode::Store(ptr, val) => {
                let ptr_name = self.get_value_name(*ptr);
                let val_name = self.get_value_name(*val);
                self.emit_line(&format!("{} = {};", ptr_name, val_name));
            }

            IrNode::GetElementPtr(ptr, indices) => {
                let ptr_name = self.get_value_name(*ptr);
                let idx_name = self.get_value_name(indices[0]);
                self.emit_line(&format!(
                    "{} {} = {}[{}];",
                    ty, result_name, ptr_name, idx_name
                ));
            }

            IrNode::SharedAlloc(elem_ty, count) => {
                let elem = self.lower_type(elem_ty);
                self.emit_line(&format!("threadgroup {} {}[{}];", elem, result_name, count));
            }

            // GPU indexing
            IrNode::ThreadId(dim) => {
                let idx = self.lower_dimension(dim, "thread_position_in_threadgroup");
                self.emit_line(&format!("{} {} = {};", ty, result_name, idx));
            }

            IrNode::BlockId(dim) => {
                let idx = self.lower_dimension(dim, "threadgroup_position_in_grid");
                self.emit_line(&format!("{} {} = {};", ty, result_name, idx));
            }

            IrNode::BlockDim(dim) => {
                let idx = self.lower_dimension(dim, "threads_per_threadgroup");
                self.emit_line(&format!("{} {} = {};", ty, result_name, idx));
            }

            IrNode::GridDim(dim) => {
                let idx = self.lower_dimension(dim, "threadgroups_per_grid");
                self.emit_line(&format!("{} {} = {};", ty, result_name, idx));
            }

            IrNode::GlobalThreadId(dim) => {
                let idx = self.lower_dimension(dim, "thread_position_in_grid");
                self.emit_line(&format!("{} {} = {};", ty, result_name, idx));
            }

            IrNode::WarpId => {
                self.emit_line(&format!(
                    "{} {} = simdgroup_index_in_threadgroup;",
                    ty, result_name
                ));
            }

            IrNode::LaneId => {
                self.emit_line(&format!(
                    "{} {} = thread_index_in_simdgroup;",
                    ty, result_name
                ));
            }

            // Synchronization
            IrNode::Barrier => {
                self.emit_line("threadgroup_barrier(mem_flags::mem_threadgroup);");
            }

            IrNode::MemoryFence(scope) => {
                let fence = match scope {
                    MemoryScope::Thread => "threadgroup_barrier(mem_flags::mem_none)",
                    MemoryScope::Threadgroup => "threadgroup_barrier(mem_flags::mem_threadgroup)",
                    MemoryScope::Device => "threadgroup_barrier(mem_flags::mem_device)",
                    MemoryScope::System => "threadgroup_barrier(mem_flags::mem_device)",
                };
                self.emit_line(&format!("{};", fence));
            }

            IrNode::GridSync => {
                return Err(MslLoweringError::UnsupportedOperation(
                    "Grid sync not supported in Metal".to_string(),
                ));
            }

            // Atomics
            IrNode::Atomic(op, ptr, val) => {
                let ptr_name = self.get_value_name(*ptr);
                let val_name = self.get_value_name(*val);
                let atomic_fn = match op {
                    AtomicOp::Add => "atomic_fetch_add_explicit",
                    AtomicOp::Sub => "atomic_fetch_sub_explicit",
                    AtomicOp::Exchange => "atomic_exchange_explicit",
                    AtomicOp::Min => "atomic_fetch_min_explicit",
                    AtomicOp::Max => "atomic_fetch_max_explicit",
                    AtomicOp::And => "atomic_fetch_and_explicit",
                    AtomicOp::Or => "atomic_fetch_or_explicit",
                    AtomicOp::Xor => "atomic_fetch_xor_explicit",
                    AtomicOp::Load => {
                        self.emit_line(&format!(
                            "{} {} = atomic_load_explicit(&{}, memory_order_relaxed);",
                            ty, result_name, ptr_name
                        ));
                        return Ok(());
                    }
                    AtomicOp::Store => {
                        self.emit_line(&format!(
                            "atomic_store_explicit(&{}, {}, memory_order_relaxed);",
                            ptr_name, val_name
                        ));
                        return Ok(());
                    }
                };
                self.emit_line(&format!(
                    "{} {} = {}(&{}, {}, memory_order_relaxed);",
                    ty, result_name, atomic_fn, ptr_name, val_name
                ));
            }

            IrNode::AtomicCas(ptr, expected, desired) => {
                let ptr_name = self.get_value_name(*ptr);
                let exp_name = self.get_value_name(*expected);
                let des_name = self.get_value_name(*desired);
                self.emit_line(&format!("{} {} = {};", ty, result_name, exp_name));
                self.emit_line(&format!(
                    "atomic_compare_exchange_weak_explicit(&{}, &{}, {}, memory_order_relaxed, memory_order_relaxed);",
                    ptr_name, result_name, des_name
                ));
            }

            // SIMD group operations
            IrNode::WarpVote(op, val) => {
                if !self.config.simd_groups {
                    return Err(MslLoweringError::UnsupportedOperation(
                        "SIMD group operations require simd_groups feature".to_string(),
                    ));
                }
                let val_name = self.get_value_name(*val);
                let vote_fn = match op {
                    WarpVoteOp::All => "simd_all",
                    WarpVoteOp::Any => "simd_any",
                    WarpVoteOp::Ballot => "simd_ballot",
                };
                self.emit_line(&format!(
                    "{} {} = {}({});",
                    ty, result_name, vote_fn, val_name
                ));
            }

            IrNode::WarpShuffle(op, val, lane) => {
                if !self.config.simd_groups {
                    return Err(MslLoweringError::UnsupportedOperation(
                        "SIMD shuffle requires simd_groups feature".to_string(),
                    ));
                }
                let val_name = self.get_value_name(*val);
                let lane_name = self.get_value_name(*lane);
                let shfl_fn = match op {
                    WarpShuffleOp::Index => "simd_shuffle",
                    WarpShuffleOp::Up => "simd_shuffle_up",
                    WarpShuffleOp::Down => "simd_shuffle_down",
                    WarpShuffleOp::Xor => "simd_shuffle_xor",
                };
                self.emit_line(&format!(
                    "{} {} = {}({}, {});",
                    ty, result_name, shfl_fn, val_name, lane_name
                ));
            }

            // Select
            IrNode::Select(cond, then_val, else_val) => {
                let cond_name = self.get_value_name(*cond);
                let then_name = self.get_value_name(*then_val);
                let else_name = self.get_value_name(*else_val);
                self.emit_line(&format!(
                    "{} {} = select({}, {}, {});",
                    ty, result_name, else_name, then_name, cond_name
                ));
            }

            // Math functions
            IrNode::Math(op, args) => {
                let fn_name = self.lower_math_op(op);
                let args_str: Vec<String> = args.iter().map(|a| self.get_value_name(*a)).collect();
                self.emit_line(&format!(
                    "{} {} = {}({});",
                    ty,
                    result_name,
                    fn_name,
                    args_str.join(", ")
                ));
            }

            // Skip nodes that don't produce MSL output
            IrNode::Parameter(_) | IrNode::Undef | IrNode::Phi(_) => {}

            // ========================================================================
            // Messaging Operations
            // ========================================================================

            // K2H (Kernel-to-Host) enqueue
            IrNode::K2HEnqueue(value) => {
                let val_name = self.get_value_name(*value);
                // Enqueue returns success status (bool)
                self.emit_line(&format!(
                    "{} {} = ringkernel_k2h_enqueue({});",
                    ty, result_name, val_name
                ));
            }

            // H2K (Host-to-Kernel) dequeue
            IrNode::H2KDequeue => {
                // Dequeue returns the message struct
                self.emit_line(&format!(
                    "{} {} = ringkernel_h2k_dequeue();",
                    ty, result_name
                ));
            }

            // H2K queue empty check
            IrNode::H2KIsEmpty => {
                // Returns true if queue is empty
                self.emit_line(&format!(
                    "{} {} = ringkernel_h2k_is_empty();",
                    ty, result_name
                ));
            }

            // K2K (Kernel-to-Kernel) send
            IrNode::K2KSend(target_id, message) => {
                let target_name = self.get_value_name(*target_id);
                let msg_name = self.get_value_name(*message);
                // Send returns success status (bool)
                self.emit_line(&format!(
                    "{} {} = ringkernel_k2k_send({}, {});",
                    ty, result_name, target_name, msg_name
                ));
            }

            // K2K blocking receive
            IrNode::K2KRecv => {
                // Blocking receive returns the message struct
                self.emit_line(&format!(
                    "{} {} = ringkernel_k2k_recv();",
                    ty, result_name
                ));
            }

            // K2K non-blocking try receive
            IrNode::K2KTryRecv => {
                // Try receive returns optional message (use .valid field to check)
                self.emit_line(&format!(
                    "{} {} = ringkernel_k2k_try_recv();",
                    ty, result_name
                ));
            }

            // ========================================================================
            // HLC (Hybrid Logical Clock) Operations
            // ========================================================================

            // Get current HLC time
            IrNode::HlcNow => {
                // Returns current HLC timestamp (uint64_t)
                self.emit_line(&format!(
                    "{} {} = ringkernel_hlc_now();",
                    ty, result_name
                ));
            }

            // Tick HLC and return new time
            IrNode::HlcTick => {
                // Increments logical counter and returns new timestamp
                self.emit_line(&format!(
                    "{} {} = ringkernel_hlc_tick();",
                    ty, result_name
                ));
            }

            // Update HLC from incoming timestamp
            IrNode::HlcUpdate(incoming) => {
                let incoming_name = self.get_value_name(*incoming);
                // Updates HLC using max(local, incoming) + 1 rule
                self.emit_line(&format!(
                    "{} {} = ringkernel_hlc_update({});",
                    ty, result_name, incoming_name
                ));
            }

            _ => {
                self.emit_line(&format!("// Unhandled: {:?}", node));
            }
        }

        Ok(())
    }

    fn emit_terminator(
        &mut self,
        _module: &IrModule,
        term: &Terminator,
    ) -> Result<(), MslLoweringError> {
        match term {
            Terminator::Return(None) => {
                self.emit_line("return;");
            }
            Terminator::Return(Some(val)) => {
                let val_name = self.get_value_name(*val);
                self.emit_line(&format!("// Return: {}", val_name));
                self.emit_line("return;");
            }
            Terminator::Branch(target) => {
                let label = self.block_labels.get(target).cloned().unwrap_or_default();
                self.emit_line(&format!("goto {};", label));
            }
            Terminator::CondBranch(cond, then_block, else_block) => {
                let cond_name = self.get_value_name(*cond);
                let then_label = self
                    .block_labels
                    .get(then_block)
                    .cloned()
                    .unwrap_or_default();
                let else_label = self
                    .block_labels
                    .get(else_block)
                    .cloned()
                    .unwrap_or_default();
                self.emit_line(&format!(
                    "if ({}) goto {}; else goto {};",
                    cond_name, then_label, else_label
                ));
            }
            Terminator::Switch(val, default, cases) => {
                let val_name = self.get_value_name(*val);
                self.emit_line(&format!("switch ({}) {{", val_name));
                self.indent += 1;
                for (case_val, target) in cases {
                    let case_str = self.lower_constant(case_val);
                    let label = self.block_labels.get(target).cloned().unwrap_or_default();
                    self.emit_line(&format!("case {}: goto {};", case_str, label));
                }
                let default_label = self.block_labels.get(default).cloned().unwrap_or_default();
                self.emit_line(&format!("default: goto {};", default_label));
                self.indent -= 1;
                self.emit_line("}");
            }
            Terminator::Unreachable => {
                self.emit_line("// unreachable");
            }
        }
        Ok(())
    }

    fn lower_type(&self, ty: &IrType) -> String {
        match ty {
            IrType::Void => "void".to_string(),
            IrType::Scalar(s) => self.lower_scalar_type(s),
            IrType::Vector(v) => format!("{}{}", self.lower_scalar_type(&v.element), v.count),
            IrType::Ptr(inner) => format!("device {}*", self.lower_type(inner)),
            IrType::Array(inner, size) => format!("array<{}, {}>", self.lower_type(inner), size),
            IrType::Slice(inner) => format!("device {}*", self.lower_type(inner)),
            IrType::Struct(s) => s.name.clone(),
            IrType::Function(_) => "void*".to_string(),
        }
    }

    fn lower_scalar_type(&self, ty: &ScalarType) -> String {
        match ty {
            ScalarType::Bool => "bool",
            ScalarType::I8 => "char",
            ScalarType::I16 => "short",
            ScalarType::I32 => "int",
            ScalarType::I64 => "long",
            ScalarType::U8 => "uchar",
            ScalarType::U16 => "ushort",
            ScalarType::U32 => "uint",
            ScalarType::U64 => "ulong",
            ScalarType::F16 => "half",
            ScalarType::F32 => "float",
            ScalarType::F64 => "float", // Metal doesn't support f64
        }
        .to_string()
    }

    fn lower_constant(&self, c: &ConstantValue) -> String {
        match c {
            ConstantValue::Bool(b) => if *b { "true" } else { "false" }.to_string(),
            ConstantValue::I32(v) => format!("{}", v),
            ConstantValue::I64(v) => format!("{}L", v),
            ConstantValue::U32(v) => format!("{}u", v),
            ConstantValue::U64(v) => format!("{}uL", v),
            ConstantValue::F32(v) => format!("{}f", v),
            ConstantValue::F64(v) => format!("{}f", *v as f32), // Downcast
            ConstantValue::Null => "nullptr".to_string(),
            ConstantValue::Array(elems) => {
                let elems_str: Vec<String> = elems.iter().map(|e| self.lower_constant(e)).collect();
                format!("{{{}}}", elems_str.join(", "))
            }
            ConstantValue::Struct(fields) => {
                let fields_str: Vec<String> =
                    fields.iter().map(|f| self.lower_constant(f)).collect();
                format!("{{{}}}", fields_str.join(", "))
            }
        }
    }

    fn lower_binary_op(&self, op: &BinaryOp, lhs: &str, rhs: &str) -> String {
        match op {
            BinaryOp::Add => format!("{} + {}", lhs, rhs),
            BinaryOp::Sub => format!("{} - {}", lhs, rhs),
            BinaryOp::Mul => format!("{} * {}", lhs, rhs),
            BinaryOp::Div => format!("{} / {}", lhs, rhs),
            BinaryOp::Rem => format!("{} % {}", lhs, rhs),
            BinaryOp::And => format!("{} & {}", lhs, rhs),
            BinaryOp::Or => format!("{} | {}", lhs, rhs),
            BinaryOp::Xor => format!("{} ^ {}", lhs, rhs),
            BinaryOp::Shl => format!("{} << {}", lhs, rhs),
            BinaryOp::Shr => format!("{} >> {}", lhs, rhs),
            BinaryOp::Sar => format!("{} >> {}", lhs, rhs),
            BinaryOp::Fma => format!("fma({}, {}, 0.0f)", lhs, rhs),
            BinaryOp::Pow => format!("pow({}, {})", lhs, rhs),
            BinaryOp::Min => format!("min({}, {})", lhs, rhs),
            BinaryOp::Max => format!("max({}, {})", lhs, rhs),
        }
    }

    fn lower_unary_op(&self, op: &UnaryOp, val: &str) -> String {
        match op {
            UnaryOp::Neg => format!("-{}", val),
            UnaryOp::Not => format!("~{}", val),
            UnaryOp::LogicalNot => format!("!{}", val),
            UnaryOp::Abs => format!("abs({})", val),
            UnaryOp::Sqrt => format!("sqrt({})", val),
            UnaryOp::Rsqrt => format!("rsqrt({})", val),
            UnaryOp::Floor => format!("floor({})", val),
            UnaryOp::Ceil => format!("ceil({})", val),
            UnaryOp::Round => format!("round({})", val),
            UnaryOp::Trunc => format!("trunc({})", val),
            UnaryOp::Sign => format!("sign({})", val),
        }
    }

    fn lower_compare_op(&self, op: &CompareOp) -> &'static str {
        match op {
            CompareOp::Eq => "==",
            CompareOp::Ne => "!=",
            CompareOp::Lt => "<",
            CompareOp::Le => "<=",
            CompareOp::Gt => ">",
            CompareOp::Ge => ">=",
        }
    }

    fn lower_dimension(&self, dim: &Dimension, prefix: &str) -> String {
        match dim {
            Dimension::X => format!("{}.x", prefix),
            Dimension::Y => format!("{}.y", prefix),
            Dimension::Z => format!("{}.z", prefix),
        }
    }

    fn lower_math_op(&self, op: &MathOp) -> &'static str {
        match op {
            MathOp::Sin => "sin",
            MathOp::Cos => "cos",
            MathOp::Tan => "tan",
            MathOp::Asin => "asin",
            MathOp::Acos => "acos",
            MathOp::Atan => "atan",
            MathOp::Atan2 => "atan2",
            MathOp::Sinh => "sinh",
            MathOp::Cosh => "cosh",
            MathOp::Tanh => "tanh",
            MathOp::Exp => "exp",
            MathOp::Exp2 => "exp2",
            MathOp::Log => "log",
            MathOp::Log2 => "log2",
            MathOp::Log10 => "log10",
            MathOp::Lerp => "mix",
            MathOp::Clamp => "clamp",
            MathOp::Step => "step",
            MathOp::SmoothStep => "smoothstep",
            MathOp::Fract => "fract",
            MathOp::CopySign => "copysign",
        }
    }

    fn get_value_name(&self, id: ValueId) -> String {
        self.value_names
            .get(&id)
            .cloned()
            .unwrap_or_else(|| format!("v{}", id.raw()))
    }

    fn get_or_create_name(&mut self, id: ValueId) -> String {
        if let Some(name) = self.value_names.get(&id) {
            return name.clone();
        }
        let name = format!("t{}", self.name_counter);
        self.name_counter += 1;
        self.value_names.insert(id, name.clone());
        name
    }

    fn emit_line(&mut self, line: &str) {
        let indent = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent, line).unwrap();
    }
}

/// MSL lowering errors.
#[derive(Debug, Clone)]
pub enum MslLoweringError {
    /// Unsupported capability.
    UnsupportedCapability(String),
    /// Unsupported operation.
    UnsupportedOperation(String),
    /// Undefined block reference.
    UndefinedBlock(BlockId),
    /// Undefined value reference.
    UndefinedValue(ValueId),
    /// Type error.
    TypeError(String),
}

impl std::fmt::Display for MslLoweringError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MslLoweringError::UnsupportedCapability(cap) => {
                write!(f, "Unsupported capability: {}", cap)
            }
            MslLoweringError::UnsupportedOperation(op) => {
                write!(f, "Unsupported operation: {}", op)
            }
            MslLoweringError::UndefinedBlock(id) => write!(f, "Undefined block: {}", id),
            MslLoweringError::UndefinedValue(id) => write!(f, "Undefined value: {}", id),
            MslLoweringError::TypeError(msg) => write!(f, "Type error: {}", msg),
        }
    }
}

impl std::error::Error for MslLoweringError {}

/// Convenience function to lower IR to MSL.
pub fn lower_to_msl(module: &IrModule) -> Result<String, MslLoweringError> {
    MslLowering::new(MslLoweringConfig::default()).lower(module)
}

/// Lower IR to MSL with custom config.
pub fn lower_to_msl_with_config(
    module: &IrModule,
    config: MslLoweringConfig,
) -> Result<String, MslLoweringError> {
    MslLowering::new(config).lower(module)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::IrBuilder;

    #[test]
    fn test_lower_simple_kernel() {
        let mut builder = IrBuilder::new("add_one");

        let _x = builder.parameter("x", IrType::ptr(IrType::F32));
        let _n = builder.parameter("n", IrType::I32);

        let idx = builder.global_thread_id(Dimension::X);
        let _ = idx;

        builder.ret();

        let module = builder.build();
        let msl = lower_to_msl(&module).unwrap();

        assert!(msl.contains("kernel void"));
        assert!(msl.contains("add_one"));
        assert!(msl.contains("thread_position_in_grid"));
    }

    #[test]
    fn test_lower_with_threadgroup_memory() {
        let mut builder = IrBuilder::new("reduce");

        let shared = builder.shared_alloc(IrType::F32, 256);
        let _ = shared;

        builder.barrier();
        builder.ret();

        let module = builder.build();
        let msl = lower_to_msl(&module).unwrap();

        assert!(msl.contains("threadgroup float"));
        assert!(msl.contains("threadgroup_barrier"));
    }

    #[test]
    fn test_lower_with_simd_ops() {
        let mut builder = IrBuilder::new("simd");

        let val = builder.const_bool(true);
        let _ = val;

        builder.ret();

        let module = builder.build();
        let config = MslLoweringConfig::metal3();
        let msl = lower_to_msl_with_config(&module, config).unwrap();

        assert!(msl.contains("#include <metal_stdlib>"));
    }

    #[test]
    fn test_lower_with_atomics() {
        let mut builder = IrBuilder::new("atomic");

        let counter = builder.parameter("counter", IrType::ptr(IrType::U32));
        let one = builder.const_u32(1);
        let _old = builder.atomic_add(counter, one);

        builder.ret();

        let module = builder.build();
        let msl = lower_to_msl(&module).unwrap();

        assert!(msl.contains("atomic_fetch_add_explicit"));
    }

    #[test]
    fn test_lower_rejects_grid_sync() {
        let mut builder = IrBuilder::new("grid");
        builder.grid_sync();
        builder.ret();

        let module = builder.build();
        let result = lower_to_msl(&module);

        assert!(result.is_err());
    }
}
