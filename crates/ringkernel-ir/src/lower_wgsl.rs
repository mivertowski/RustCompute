//! IR to WGSL lowering pass.
//!
//! Lowers IR to WebGPU Shading Language for cross-platform GPU compute.

use std::collections::HashMap;
use std::fmt::Write;

use crate::{
    nodes::*, BackendCapabilities, BlockId, CapabilityFlag, Dimension, IrModule, IrNode,
    IrType, ScalarType, Terminator, ValueId,
};

/// WGSL lowering configuration.
#[derive(Debug, Clone)]
pub struct WgslLoweringConfig {
    /// Enable subgroup operations (if available).
    pub subgroups: bool,
    /// Workgroup size.
    pub workgroup_size: (u32, u32, u32),
    /// Emulate 64-bit atomics using 32-bit pairs.
    pub emulate_atomic64: bool,
    /// Downcast f64 to f32 (WGSL doesn't support f64).
    pub downcast_f64: bool,
    /// Generate debug comments.
    pub debug: bool,
}

impl Default for WgslLoweringConfig {
    fn default() -> Self {
        Self {
            subgroups: false,
            workgroup_size: (256, 1, 1),
            emulate_atomic64: true,
            downcast_f64: true,
            debug: false,
        }
    }
}

impl WgslLoweringConfig {
    /// Enable subgroup operations.
    pub fn with_subgroups(mut self) -> Self {
        self.subgroups = true;
        self
    }

    /// Set workgroup size.
    pub fn with_workgroup_size(mut self, x: u32, y: u32, z: u32) -> Self {
        self.workgroup_size = (x, y, z);
        self
    }
}

/// WGSL code generator.
pub struct WgslLowering {
    config: WgslLoweringConfig,
    output: String,
    indent: usize,
    value_names: HashMap<ValueId, String>,
    name_counter: usize,
    block_labels: HashMap<BlockId, String>,
    #[allow(dead_code)]
    has_f64_warning: bool,
}

impl WgslLowering {
    /// Create a new WGSL lowering pass.
    pub fn new(config: WgslLoweringConfig) -> Self {
        Self {
            config,
            output: String::new(),
            indent: 0,
            value_names: HashMap::new(),
            name_counter: 0,
            block_labels: HashMap::new(),
            has_f64_warning: false,
        }
    }

    /// Lower an IR module to WGSL code.
    pub fn lower(mut self, module: &IrModule) -> Result<String, WgslLoweringError> {
        // Check capabilities
        self.check_capabilities(module)?;

        // Generate bindings and structs
        self.emit_header(module);

        // Generate compute shader
        self.emit_compute_shader(module)?;

        Ok(self.output)
    }

    fn check_capabilities(&self, module: &IrModule) -> Result<(), WgslLoweringError> {
        // Capability tracking for future use
        let _wgpu_caps = if self.config.subgroups {
            BackendCapabilities::wgpu_with_subgroups()
        } else {
            BackendCapabilities::wgpu_baseline()
        };

        // Check for f64 usage
        if module.required_capabilities.has(CapabilityFlag::Float64) && !self.config.downcast_f64 {
            return Err(WgslLoweringError::UnsupportedCapability(
                "f64 not supported in WGSL (use downcast_f64 option)".to_string(),
            ));
        }

        // Check for atomic64
        if module.required_capabilities.has(CapabilityFlag::Atomic64) && !self.config.emulate_atomic64 {
            return Err(WgslLoweringError::UnsupportedCapability(
                "64-bit atomics not supported in WGSL (use emulate_atomic64 option)".to_string(),
            ));
        }

        // Check for cooperative groups
        if module.required_capabilities.has(CapabilityFlag::CooperativeGroups) {
            return Err(WgslLoweringError::UnsupportedCapability(
                "Cooperative groups / grid sync not supported in WebGPU".to_string(),
            ));
        }

        Ok(())
    }

    fn emit_header(&mut self, module: &IrModule) {
        self.emit_line("// Generated by ringkernel-ir WGSL lowering");
        self.emit_line("");

        // Emit subgroup enable if needed
        if self.config.subgroups {
            self.emit_line("enable subgroups;");
            self.emit_line("");
        }

        // Emit parameter structs
        if !module.parameters.is_empty() {
            self.emit_line("// Parameters");
            self.emit_line("struct Params {");
            self.indent += 1;
            for (_i, param) in module.parameters.iter().enumerate() {
                // Only emit non-pointer params in struct
                if !matches!(param.ty, IrType::Ptr(_) | IrType::Slice(_)) {
                    let ty = self.lower_type(&param.ty);
                    self.emit_line(&format!("{}: {},", param.name, ty));
                }
            }
            self.indent -= 1;
            self.emit_line("}");
            self.emit_line("");
        }

        // Emit bindings
        self.emit_line("// Bindings");
        let mut binding_idx = 0;

        // Uniform buffer for params
        let has_uniforms = module.parameters.iter().any(|p| {
            !matches!(p.ty, IrType::Ptr(_) | IrType::Slice(_))
        });
        if has_uniforms {
            self.emit_line(&format!(
                "@group(0) @binding({}) var<uniform> params: Params;",
                binding_idx
            ));
            binding_idx += 1;
        }

        // Storage buffers for pointers/slices
        for param in &module.parameters {
            if let IrType::Ptr(inner) | IrType::Slice(inner) = &param.ty {
                let elem_ty = self.lower_type(inner);
                self.emit_line(&format!(
                    "@group(0) @binding({}) var<storage, read_write> {}: array<{}>;",
                    binding_idx, param.name, elem_ty
                ));
                binding_idx += 1;
            }
        }

        self.emit_line("");
    }

    fn emit_compute_shader(&mut self, module: &IrModule) -> Result<(), WgslLoweringError> {
        // Assign names
        self.assign_names(module);

        // Workgroup size
        let (wx, wy, wz) = self.config.workgroup_size;

        self.emit_line(&format!(
            "@compute @workgroup_size({}, {}, {})",
            wx, wy, wz
        ));
        self.emit_line(&format!(
            "fn {}(",
            module.name
        ));
        self.indent += 1;
        self.emit_line("@builtin(global_invocation_id) global_id: vec3<u32>,");
        self.emit_line("@builtin(local_invocation_id) local_id: vec3<u32>,");
        self.emit_line("@builtin(workgroup_id) workgroup_id: vec3<u32>,");
        self.emit_line("@builtin(num_workgroups) num_workgroups: vec3<u32>,");
        self.indent -= 1;
        self.emit_line(") {");
        self.indent += 1;

        // Emit blocks
        self.emit_block(module, module.entry_block)?;

        self.indent -= 1;
        self.emit_line("}");

        Ok(())
    }

    fn assign_names(&mut self, module: &IrModule) {
        for param in &module.parameters {
            // For pointer/slice params, they become array accesses
            self.value_names.insert(param.value_id, param.name.clone());
        }

        for (block_id, block) in &module.blocks {
            self.block_labels.insert(*block_id, block.label.clone());
        }
    }

    fn emit_block(&mut self, module: &IrModule, block_id: BlockId) -> Result<(), WgslLoweringError> {
        let block = module
            .blocks
            .get(&block_id)
            .ok_or(WgslLoweringError::UndefinedBlock(block_id))?;

        // Note: WGSL doesn't have goto, so we use structured control flow
        // For now, emit as a sequence with comments for block labels
        if block_id != module.entry_block {
            self.emit_line(&format!("// Block: {}", block.label));
        }

        // Instructions
        for inst in &block.instructions {
            self.emit_instruction(module, &inst.result, &inst.result_type, &inst.node)?;
        }

        // Terminator
        if let Some(term) = &block.terminator {
            self.emit_terminator(module, term)?;
        }

        Ok(())
    }

    fn emit_instruction(
        &mut self,
        _module: &IrModule,
        result: &ValueId,
        result_type: &IrType,
        node: &IrNode,
    ) -> Result<(), WgslLoweringError> {
        let result_name = self.get_or_create_name(*result);
        let ty = self.lower_type(result_type);

        match node {
            // Constants
            IrNode::Constant(c) => {
                let val = self.lower_constant(c);
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, val));
            }

            // Binary operations
            IrNode::BinaryOp(op, lhs, rhs) => {
                let lhs_name = self.get_value_name(*lhs);
                let rhs_name = self.get_value_name(*rhs);
                let expr = self.lower_binary_op(op, &lhs_name, &rhs_name);
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, expr));
            }

            // Unary operations
            IrNode::UnaryOp(op, val) => {
                let val_name = self.get_value_name(*val);
                let expr = self.lower_unary_op(op, &val_name);
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, expr));
            }

            // Comparisons
            IrNode::Compare(op, lhs, rhs) => {
                let lhs_name = self.get_value_name(*lhs);
                let rhs_name = self.get_value_name(*rhs);
                let cmp_op = self.lower_compare_op(op);
                self.emit_line(&format!(
                    "var {}: bool = {} {} {};",
                    result_name, lhs_name, cmp_op, rhs_name
                ));
            }

            // Memory operations
            IrNode::Load(ptr) => {
                let ptr_name = self.get_value_name(*ptr);
                // In WGSL, arrays use [] indexing
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, ptr_name));
            }

            IrNode::Store(ptr, val) => {
                let ptr_name = self.get_value_name(*ptr);
                let val_name = self.get_value_name(*val);
                self.emit_line(&format!("{} = {};", ptr_name, val_name));
            }

            IrNode::GetElementPtr(ptr, indices) => {
                let ptr_name = self.get_value_name(*ptr);
                let idx_name = self.get_value_name(indices[0]);
                // In WGSL, this becomes an array index
                self.emit_line(&format!(
                    "var {}: {} = {}[{}];",
                    result_name, ty, ptr_name, idx_name
                ));
            }

            IrNode::SharedAlloc(_elem_ty, _count) => {
                // In WGSL, workgroup vars are declared at module scope
                // For now, emit a comment
                self.emit_line(&format!("// Workgroup var: {}", result_name));
            }

            // GPU indexing
            IrNode::ThreadId(dim) => {
                let idx = self.lower_dimension(dim, "local_id");
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, idx));
            }

            IrNode::BlockId(dim) => {
                let idx = self.lower_dimension(dim, "workgroup_id");
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, idx));
            }

            IrNode::BlockDim(dim) => {
                // In WGSL, workgroup size is a compile-time constant
                let size = match dim {
                    Dimension::X => self.config.workgroup_size.0,
                    Dimension::Y => self.config.workgroup_size.1,
                    Dimension::Z => self.config.workgroup_size.2,
                };
                self.emit_line(&format!("var {}: {} = {}u;", result_name, ty, size));
            }

            IrNode::GridDim(dim) => {
                let idx = self.lower_dimension(dim, "num_workgroups");
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, idx));
            }

            IrNode::GlobalThreadId(dim) => {
                let idx = self.lower_dimension(dim, "global_id");
                self.emit_line(&format!("var {}: {} = {};", result_name, ty, idx));
            }

            IrNode::WarpId => {
                // Approximate warp ID
                self.emit_line(&format!("var {}: {} = local_id.x / 32u;", result_name, ty));
            }

            IrNode::LaneId => {
                self.emit_line(&format!("var {}: {} = local_id.x % 32u;", result_name, ty));
            }

            // Synchronization
            IrNode::Barrier => {
                self.emit_line("workgroupBarrier();");
            }

            IrNode::MemoryFence(_scope) => {
                self.emit_line("storageBarrier();");
            }

            IrNode::GridSync => {
                return Err(WgslLoweringError::UnsupportedOperation(
                    "Grid sync not supported in WGSL".to_string(),
                ));
            }

            // Atomics
            IrNode::Atomic(op, ptr, val) => {
                let ptr_name = self.get_value_name(*ptr);
                let val_name = self.get_value_name(*val);
                let atomic_fn = match op {
                    AtomicOp::Add => "atomicAdd",
                    AtomicOp::Sub => "atomicSub",
                    AtomicOp::Exchange => "atomicExchange",
                    AtomicOp::Min => "atomicMin",
                    AtomicOp::Max => "atomicMax",
                    AtomicOp::And => "atomicAnd",
                    AtomicOp::Or => "atomicOr",
                    AtomicOp::Xor => "atomicXor",
                    AtomicOp::Load => "atomicLoad",
                    AtomicOp::Store => {
                        self.emit_line(&format!("atomicStore(&{}, {});", ptr_name, val_name));
                        return Ok(());
                    }
                };
                self.emit_line(&format!(
                    "var {}: {} = {}(&{}, {});",
                    result_name, ty, atomic_fn, ptr_name, val_name
                ));
            }

            IrNode::AtomicCas(ptr, expected, desired) => {
                let ptr_name = self.get_value_name(*ptr);
                let exp_name = self.get_value_name(*expected);
                let des_name = self.get_value_name(*desired);
                self.emit_line(&format!(
                    "var {}: {} = atomicCompareExchangeWeak(&{}, {}, {}).old_value;",
                    result_name, ty, ptr_name, exp_name, des_name
                ));
            }

            // Warp/subgroup operations
            IrNode::WarpVote(op, val) => {
                if !self.config.subgroups {
                    return Err(WgslLoweringError::UnsupportedOperation(
                        "Subgroup operations require subgroups feature".to_string(),
                    ));
                }
                let val_name = self.get_value_name(*val);
                let vote_fn = match op {
                    WarpVoteOp::All => "subgroupAll",
                    WarpVoteOp::Any => "subgroupAny",
                    WarpVoteOp::Ballot => "subgroupBallot",
                };
                self.emit_line(&format!(
                    "var {}: {} = {}({});",
                    result_name, ty, vote_fn, val_name
                ));
            }

            IrNode::WarpShuffle(op, val, lane) => {
                if !self.config.subgroups {
                    return Err(WgslLoweringError::UnsupportedOperation(
                        "Subgroup shuffle requires subgroups feature".to_string(),
                    ));
                }
                let val_name = self.get_value_name(*val);
                let lane_name = self.get_value_name(*lane);
                let shfl_fn = match op {
                    WarpShuffleOp::Index => "subgroupShuffle",
                    WarpShuffleOp::Up => "subgroupShuffleUp",
                    WarpShuffleOp::Down => "subgroupShuffleDown",
                    WarpShuffleOp::Xor => "subgroupShuffleXor",
                };
                self.emit_line(&format!(
                    "var {}: {} = {}({}, {});",
                    result_name, ty, shfl_fn, val_name, lane_name
                ));
            }

            // Select
            IrNode::Select(cond, then_val, else_val) => {
                let cond_name = self.get_value_name(*cond);
                let then_name = self.get_value_name(*then_val);
                let else_name = self.get_value_name(*else_val);
                self.emit_line(&format!(
                    "var {}: {} = select({}, {}, {});",
                    result_name, ty, else_name, then_name, cond_name
                ));
            }

            // Math functions
            IrNode::Math(op, args) => {
                let fn_name = self.lower_math_op(op);
                let args_str: Vec<String> = args.iter().map(|a| self.get_value_name(*a)).collect();
                self.emit_line(&format!(
                    "var {}: {} = {}({});",
                    result_name, ty, fn_name, args_str.join(", ")
                ));
            }

            // Skip nodes that don't produce WGSL output
            IrNode::Parameter(_) | IrNode::Undef | IrNode::Phi(_) => {}

            // Messaging (not supported in WGSL)
            IrNode::K2HEnqueue(_)
            | IrNode::H2KDequeue
            | IrNode::H2KIsEmpty
            | IrNode::K2KSend(_, _)
            | IrNode::K2KRecv
            | IrNode::K2KTryRecv
            | IrNode::HlcNow
            | IrNode::HlcTick
            | IrNode::HlcUpdate(_) => {
                self.emit_line(&format!("// Not supported in WGSL: {:?}", node));
            }

            _ => {
                self.emit_line(&format!("// Unhandled: {:?}", node));
            }
        }

        Ok(())
    }

    fn emit_terminator(
        &mut self,
        module: &IrModule,
        term: &Terminator,
    ) -> Result<(), WgslLoweringError> {
        match term {
            Terminator::Return(None) => {
                self.emit_line("return;");
            }
            Terminator::Return(Some(val)) => {
                // Compute shaders don't return values
                let val_name = self.get_value_name(*val);
                self.emit_line(&format!("// Return: {}", val_name));
                self.emit_line("return;");
            }
            Terminator::Branch(target) => {
                // WGSL doesn't have goto, emit the target block inline
                self.emit_block(module, *target)?;
            }
            Terminator::CondBranch(cond, then_block, else_block) => {
                let cond_name = self.get_value_name(*cond);
                self.emit_line(&format!("if ({}) {{", cond_name));
                self.indent += 1;
                self.emit_block(module, *then_block)?;
                self.indent -= 1;
                self.emit_line("} else {");
                self.indent += 1;
                self.emit_block(module, *else_block)?;
                self.indent -= 1;
                self.emit_line("}");
            }
            Terminator::Switch(val, default, cases) => {
                let val_name = self.get_value_name(*val);
                self.emit_line(&format!("switch ({}) {{", val_name));
                self.indent += 1;
                for (case_val, target) in cases {
                    let case_str = self.lower_constant(case_val);
                    self.emit_line(&format!("case {}: {{", case_str));
                    self.indent += 1;
                    self.emit_block(module, *target)?;
                    self.indent -= 1;
                    self.emit_line("}");
                }
                self.emit_line("default: {");
                self.indent += 1;
                self.emit_block(module, *default)?;
                self.indent -= 1;
                self.emit_line("}");
                self.indent -= 1;
                self.emit_line("}");
            }
            Terminator::Unreachable => {
                self.emit_line("// unreachable");
            }
        }
        Ok(())
    }

    fn lower_type(&self, ty: &IrType) -> String {
        match ty {
            IrType::Void => "void".to_string(),
            IrType::Scalar(s) => self.lower_scalar_type(s),
            IrType::Vector(v) => format!(
                "vec{}<{}>",
                v.count,
                self.lower_scalar_type(&v.element)
            ),
            IrType::Ptr(inner) => format!("ptr<storage, {}>", self.lower_type(inner)),
            IrType::Array(inner, size) => format!("array<{}, {}>", self.lower_type(inner), size),
            IrType::Slice(inner) => format!("array<{}>", self.lower_type(inner)),
            IrType::Struct(s) => s.name.clone(),
            IrType::Function(_) => "void".to_string(),
        }
    }

    fn lower_scalar_type(&self, ty: &ScalarType) -> String {
        match ty {
            ScalarType::Bool => "bool",
            ScalarType::I8 | ScalarType::I16 | ScalarType::I32 => "i32",
            ScalarType::I64 => {
                if self.config.emulate_atomic64 {
                    "i32" // Downcast
                } else {
                    "i32" // WGSL doesn't have i64
                }
            }
            ScalarType::U8 | ScalarType::U16 | ScalarType::U32 => "u32",
            ScalarType::U64 => "u32", // Downcast
            ScalarType::F16 => "f16",
            ScalarType::F32 => "f32",
            ScalarType::F64 => "f32", // Downcast (WGSL doesn't support f64)
        }
        .to_string()
    }

    fn lower_constant(&self, c: &ConstantValue) -> String {
        match c {
            ConstantValue::Bool(b) => if *b { "true" } else { "false" }.to_string(),
            ConstantValue::I32(v) => format!("{}i", v),
            ConstantValue::I64(v) => format!("{}i", *v as i32), // Downcast
            ConstantValue::U32(v) => format!("{}u", v),
            ConstantValue::U64(v) => format!("{}u", *v as u32), // Downcast
            ConstantValue::F32(v) => {
                if v.is_nan() {
                    "0.0f".to_string()
                } else if v.is_infinite() {
                    if *v > 0.0 { "1e38f" } else { "-1e38f" }.to_string()
                } else {
                    format!("{}f", v)
                }
            }
            ConstantValue::F64(v) => format!("{}f", *v as f32), // Downcast
            ConstantValue::Null => "0u".to_string(),
            ConstantValue::Array(elems) => {
                let elems_str: Vec<String> = elems.iter().map(|e| self.lower_constant(e)).collect();
                format!("array({})", elems_str.join(", "))
            }
            ConstantValue::Struct(fields) => {
                let fields_str: Vec<String> =
                    fields.iter().map(|f| self.lower_constant(f)).collect();
                format!("({})", fields_str.join(", "))
            }
        }
    }

    fn lower_binary_op(&self, op: &BinaryOp, lhs: &str, rhs: &str) -> String {
        match op {
            BinaryOp::Add => format!("({} + {})", lhs, rhs),
            BinaryOp::Sub => format!("({} - {})", lhs, rhs),
            BinaryOp::Mul => format!("({} * {})", lhs, rhs),
            BinaryOp::Div => format!("({} / {})", lhs, rhs),
            BinaryOp::Rem => format!("({} % {})", lhs, rhs),
            BinaryOp::And => format!("({} & {})", lhs, rhs),
            BinaryOp::Or => format!("({} | {})", lhs, rhs),
            BinaryOp::Xor => format!("({} ^ {})", lhs, rhs),
            BinaryOp::Shl => format!("({} << {})", lhs, rhs),
            BinaryOp::Shr => format!("({} >> {})", lhs, rhs),
            BinaryOp::Sar => format!("({} >> {})", lhs, rhs),
            BinaryOp::Fma => format!("fma({}, {}, 0.0)", lhs, rhs),
            BinaryOp::Pow => format!("pow({}, {})", lhs, rhs),
            BinaryOp::Min => format!("min({}, {})", lhs, rhs),
            BinaryOp::Max => format!("max({}, {})", lhs, rhs),
        }
    }

    fn lower_unary_op(&self, op: &UnaryOp, val: &str) -> String {
        match op {
            UnaryOp::Neg => format!("(-{})", val),
            UnaryOp::Not => format!("(~{})", val),
            UnaryOp::LogicalNot => format!("(!{})", val),
            UnaryOp::Abs => format!("abs({})", val),
            UnaryOp::Sqrt => format!("sqrt({})", val),
            UnaryOp::Rsqrt => format!("inverseSqrt({})", val),
            UnaryOp::Floor => format!("floor({})", val),
            UnaryOp::Ceil => format!("ceil({})", val),
            UnaryOp::Round => format!("round({})", val),
            UnaryOp::Trunc => format!("trunc({})", val),
            UnaryOp::Sign => format!("sign({})", val),
        }
    }

    fn lower_compare_op(&self, op: &CompareOp) -> &'static str {
        match op {
            CompareOp::Eq => "==",
            CompareOp::Ne => "!=",
            CompareOp::Lt => "<",
            CompareOp::Le => "<=",
            CompareOp::Gt => ">",
            CompareOp::Ge => ">=",
        }
    }

    fn lower_dimension(&self, dim: &Dimension, prefix: &str) -> String {
        match dim {
            Dimension::X => format!("{}.x", prefix),
            Dimension::Y => format!("{}.y", prefix),
            Dimension::Z => format!("{}.z", prefix),
        }
    }

    fn lower_math_op(&self, op: &MathOp) -> &'static str {
        match op {
            MathOp::Sin => "sin",
            MathOp::Cos => "cos",
            MathOp::Tan => "tan",
            MathOp::Asin => "asin",
            MathOp::Acos => "acos",
            MathOp::Atan => "atan",
            MathOp::Atan2 => "atan2",
            MathOp::Sinh => "sinh",
            MathOp::Cosh => "cosh",
            MathOp::Tanh => "tanh",
            MathOp::Exp => "exp",
            MathOp::Exp2 => "exp2",
            MathOp::Log => "log",
            MathOp::Log2 => "log2",
            MathOp::Log10 => "log",  // log10 not in WGSL, would need emulation
            MathOp::Lerp => "mix",
            MathOp::Clamp => "clamp",
            MathOp::Step => "step",
            MathOp::SmoothStep => "smoothstep",
            MathOp::Fract => "fract",
            MathOp::CopySign => "sign", // Approximate
        }
    }

    fn get_value_name(&self, id: ValueId) -> String {
        self.value_names
            .get(&id)
            .cloned()
            .unwrap_or_else(|| format!("v{}", id.raw()))
    }

    fn get_or_create_name(&mut self, id: ValueId) -> String {
        if let Some(name) = self.value_names.get(&id) {
            return name.clone();
        }
        let name = format!("t{}", self.name_counter);
        self.name_counter += 1;
        self.value_names.insert(id, name.clone());
        name
    }

    fn emit_line(&mut self, line: &str) {
        let indent = "    ".repeat(self.indent);
        writeln!(self.output, "{}{}", indent, line).unwrap();
    }
}

/// WGSL lowering errors.
#[derive(Debug, Clone)]
pub enum WgslLoweringError {
    /// Unsupported capability.
    UnsupportedCapability(String),
    /// Unsupported operation.
    UnsupportedOperation(String),
    /// Undefined block reference.
    UndefinedBlock(BlockId),
    /// Undefined value reference.
    UndefinedValue(ValueId),
    /// Type error.
    TypeError(String),
}

impl std::fmt::Display for WgslLoweringError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            WgslLoweringError::UnsupportedCapability(cap) => {
                write!(f, "Unsupported capability: {}", cap)
            }
            WgslLoweringError::UnsupportedOperation(op) => {
                write!(f, "Unsupported operation: {}", op)
            }
            WgslLoweringError::UndefinedBlock(id) => write!(f, "Undefined block: {}", id),
            WgslLoweringError::UndefinedValue(id) => write!(f, "Undefined value: {}", id),
            WgslLoweringError::TypeError(msg) => write!(f, "Type error: {}", msg),
        }
    }
}

impl std::error::Error for WgslLoweringError {}

/// Convenience function to lower IR to WGSL.
pub fn lower_to_wgsl(module: &IrModule) -> Result<String, WgslLoweringError> {
    WgslLowering::new(WgslLoweringConfig::default()).lower(module)
}

/// Lower IR to WGSL with custom config.
pub fn lower_to_wgsl_with_config(
    module: &IrModule,
    config: WgslLoweringConfig,
) -> Result<String, WgslLoweringError> {
    WgslLowering::new(config).lower(module)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::IrBuilder;

    #[test]
    fn test_lower_simple_kernel() {
        let mut builder = IrBuilder::new("add_one");

        let _x = builder.parameter("x", IrType::slice(IrType::F32));
        let _n = builder.parameter("n", IrType::I32);

        let idx = builder.global_thread_id(Dimension::X);
        let _ = idx;

        builder.ret();

        let module = builder.build();
        let wgsl = lower_to_wgsl(&module).unwrap();

        assert!(wgsl.contains("@compute @workgroup_size"));
        assert!(wgsl.contains("fn add_one"));
        assert!(wgsl.contains("global_id"));
    }

    #[test]
    fn test_lower_with_barrier() {
        let mut builder = IrBuilder::new("sync");

        builder.barrier();
        builder.ret();

        let module = builder.build();
        let wgsl = lower_to_wgsl(&module).unwrap();

        assert!(wgsl.contains("workgroupBarrier()"));
    }

    #[test]
    fn test_lower_with_control_flow() {
        let mut builder = IrBuilder::new("branch");

        let cond = builder.const_bool(true);
        let then_block = builder.create_block("then");
        let else_block = builder.create_block("else");

        builder.cond_branch(cond, then_block, else_block);

        builder.switch_to_block(then_block);
        builder.ret();

        builder.switch_to_block(else_block);
        builder.ret();

        let module = builder.build();
        let wgsl = lower_to_wgsl(&module).unwrap();

        assert!(wgsl.contains("if ("));
        assert!(wgsl.contains("} else {"));
    }

    #[test]
    fn test_lower_rejects_grid_sync() {
        let mut builder = IrBuilder::new("grid");
        builder.grid_sync();
        builder.ret();

        let module = builder.build();
        let result = lower_to_wgsl(&module);

        assert!(result.is_err());
    }

    #[test]
    fn test_lower_with_subgroups() {
        let mut builder = IrBuilder::new("subgroup");

        let val = builder.const_bool(true);
        // WarpVote requires subgroups capability

        builder.ret();

        let module = builder.build();
        let config = WgslLoweringConfig::default().with_subgroups();
        let wgsl = lower_to_wgsl_with_config(&module, config).unwrap();

        assert!(wgsl.contains("enable subgroups;"));
    }
}
